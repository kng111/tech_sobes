# (Принцип подстановки Барбары Лисков).
# Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.

class Bird:
    def fly(self):
        return "Flying"

    def make_sound(self):
        return "Chirp"
    
    def zxc(self):
        return '456'

class Sparrow(Bird):
    def make_sound(self):
        return "AFK"

class Penguin(Bird):
    def fly(self):
        return "Can't fly"

    def make_sound(self):
        return "Honk"

class Eagle(Bird):
    def zxc(self):
        return "123"

# Функция, использующая объекты класса Bird
def bird_actions(bird):
    print(f"{bird.fly()}, {bird.make_sound()}, {bird.zxc()}")

# Создание объектов разных подклассов Bird
sparrow = Sparrow()
penguin = Penguin()
eagle = Eagle()

# Использование функции с объектами разных подклассов Bird
bird_actions(sparrow)  # Выводит "Flying, Chirp"
bird_actions(penguin)  # Выводит "Can't fly, Honk"
bird_actions(eagle)  

"""
ПЛЮСЫ:
    Гибкость кода:
        Код, написанный с учетом LSP,
          становится более гибким.
            Подклассы могут быть использованы вместо своих суперклассов,
                что обеспечивает легкость расширения и поддержки.

    Совместимость существующего кода:
        Подклассы, соответствующие LSP, могут безопасно заменять свои суперклассы в существующем коде

    Повторное использование кода:
        Возможность заменять объекты суперкласса их подклассами способствует повторному использованию кода
    
    
    Улучшенная абстракция:
        LSP поддерживает создание абстракций,
          позволяя сосредоточиться на общих чертах поведения в суперклассе
            и способствуя корректному использованию подклассов.
    
    Обеспечение согласованности:

    Снижение риска ошибок:

    Легкость тестирования и отладки:

    Улучшенная читаемость и понимание кода:
"""

"""
Кратко:
    Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.

Зачем использовать:
    Принцип подстановки Барбары Лисков (LSP) стоит использовать,
      потому что он обеспечивает гибкость кода,
        совместимость существующего кода,
          повторное использование кода,
            улучшенную абстракцию,
              согласованность,
                снижение риска ошибок,
                  легкость тестирования и отладки,
                    а также улучшенную читаемость и понимание кода.

"""